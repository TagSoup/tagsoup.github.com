<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nodejs | Phx Tag Soup]]></title>
  <link href="http://TagSoup.github.com/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://TagSoup.github.com/"/>
  <updated>2012-10-09T17:25:56-07:00</updated>
  <id>http://TagSoup.github.com/</id>
  <author>
    <name><![CDATA[Phx Tag Soup]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Polling is for chumps - node.js with EventSource]]></title>
    <link href="http://TagSoup.github.com/blog/2012/02/22/polling-is-for-chumps/"/>
    <updated>2012-02-22T00:23:00-07:00</updated>
    <id>http://TagSoup.github.com/blog/2012/02/22/polling-is-for-chumps</id>
    <content type="html"><![CDATA[<p>You know what sucks? Making hundreds of round trips to a server to see if there's any new data you can grab.</p>

<p>But modern browsers (well, Firefox and Chrome and Safari) support a much neater option. With the right <code>Content-Type</code> header, some special sauce in the client, and a modern browser platform, you can use the HTML5 <a href="http://dev.w3.org/html5/eventsource/">EventSource API</a> to establish a single long-term connection for each client, and the server pushes new data whenever necessary.</p>

<p>Let's start with a look at the server-side implementation.</p>

<p><div><script src='https://gist.github.com/1883462.js?file=app-server.js'></script>
<noscript><pre><code>var express = require('express');
var fs = require('fs');

// change this to some other log file that doesn't require root permissions to read :)
var logfile = '/var/log/messages';

var app = module.exports = express.createServer();

app.configure(function(){
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(express.static(__dirname + '/public'));
});

app.configure('development', function(){
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));␣
});

app.configure('production', function(){
  app.use(express.errorHandler());␣
});

app.get('/', function(req, res) { res.redirect('/index.html') });

app.error(function(err, req, res, next) {
    console.log('error: ' + err );
});

app.get('/events', function(req, res) {
    var id = (new Date()).toLocaleTimeString();
    res.header('Content-Type', 'text/event-stream');
    res.header('Cache-Control', 'no-cache');
    res.header('Connection', 'keep-alive');

    fs.open(logfile, 'r', function(err, fd) {
        // Whenever new data is available to read, send it to the client
        fs.watchFile(logfile, function(curr, prev) {
            if (curr.size &gt; prev.size) {
                var size = curr.size - prev.size;
                var data = new Buffer(size);
                fs.read(fd, data, 0, size, prev.size, function(err, bytesRead, buffer) {
                    res.write('id: ' + id + '\n');
                    res.write('event: data\n');
                    res.write('data: ' + data.toString('utf8') + '\n\n');
                });
            }
        });

        // If the client disconnects, let's not leak any resources
        res.on('close', function() {
            fs.unwatchFile(logfile);
            fs.close(fd);
        });
    });
});

app.listen(process.env.PORT || 3000);
console.log(&quot;tailpipe listening on port %d in %s mode&quot;, app.address().port, app.settings.env);</code></pre></noscript></div>
</p>

<p>Things to note: The secret sauce here is all in the <code>/events</code> handler. It's pretty simple - we watch a log file to see when its size changes, and when that happens, we read the new data from the end of the file and send it to the client tagged with the event name <code>data</code> (so if you have multiple kinds of events, you can interleave different messages by tagging them with different <code>event</code> names and the client will be able to properly distinguish them). And of course, if the client closes the connection, we want to free up the open file descriptor and the watch on the logfile.</p>

<p>Now, how do we consume this data from the client?</p>

<p><div><script src='https://gist.github.com/1883462.js?file=app-client.js'></script>
<noscript><pre><code>$.ready(function() {
  var source = new EventSource(&quot;/events&quot;);
  source.addEventListener('data', function(e) {
    $(&quot;#content&quot;).append(e.data + &quot;\n&quot;);
  }, false);
});</code></pre></noscript></div>
</p>

<p>It's so simple it almost doesn't need an explanation. The important things to note are: of course the URL has to point at the same endpoint that the server is exporting the stream on, and we add a listener for the <code>data</code> event which we know the messages from the server will be tagged with. If you want to support multiple message types, you just add another listener on the client for each different <code>event</code> name and you're good to go.</p>
]]></content>
  </entry>
  
</feed>
