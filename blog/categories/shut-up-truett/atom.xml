<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shut Up Truett | Phx Tag Soup]]></title>
  <link href="http://TagSoup.github.com/blog/categories/shut-up-truett/atom.xml" rel="self"/>
  <link href="http://TagSoup.github.com/"/>
  <updated>2012-10-18T23:11:28-07:00</updated>
  <id>http://TagSoup.github.com/</id>
  <author>
    <name><![CDATA[Phx Tag Soup]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Bit on Process]]></title>
    <link href="http://TagSoup.github.com/blog/2012/03/13/a-bit-on-process/"/>
    <updated>2012-03-13T08:31:00-07:00</updated>
    <id>http://TagSoup.github.com/blog/2012/03/13/a-bit-on-process</id>
    <content type="html"><![CDATA[<h3>Day 19 of the 30 Day Writing Challenge</h3>

<p>I can't think of anything more uniformly despised by everyone in my career than process.  Just mentioning the word generally causes a visible reaction.  That isn't a good thing.  A good process should be your best friend that makes everything else in your life easier.  I know why everyone reacts that way.  We've all worked somewhere with a rigid process whose endless meetings and documents detract more than they add.  That doesn’t mean process itself is bad, just that those processes are.</p>

<p>A process doesn’t have to be rigid.  It doesn’t even have to cover development lifecycle if you don’t want it to. If you notice a recurring problem, implement a rule to solve it.  Say, for example, you are regularly deploying sites and the links don’t function properly.   This is clearly a problem, and bad for you.  Now we identify what caused that problem.  In this example it was the page was never tested in IE7, and some of the fancy modern code doesn’t work there.  How was that missed?  We never identified what browsers the client expected the site to function properly in.  So we now have the rule,  “Identify all required support configurations from client prior to the start of development.” Congratulations, you have a process.  It’s that simple.  There is no one process that will solve every organization’s problems.   Every company is going to have to tailor their own process.
 <!-- more -->
The assumption that adopting a predefined process will work is a common mistake.  It’s an understandable one to make too.  The entire idea of process is that it should make your life easier.  What is easier than following a define set of steps?  However, just like you can’t copy and paste the same code from one project to the next, you can’t just copy someone’s process.  Their needs aren’t your needs.  So identify those needs.  Does management want greater visibility?  Are project managers asking you to add, “just one small thing,” to the sprint?  Our job as developers is to solve problems.  There is no reason we can’t solve our own.</p>

<p>Before I end this, I will admit I’m biased towards process.  I’m a QA, without process my life is very hectic.  QA thrives in controlled environments.  If I’m given reliable inputs (Requirements Docs, Support Configurations, User Stories, etc.), I can’t guarantee the outputs of my testing.  I can assure you, without process requirements that those things exist, they won’t.  This leads incomplete testing, and thus quality problems.  No one likes those.   So help us help you better, create a process</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pest Control 2: Electric Boogaloo]]></title>
    <link href="http://TagSoup.github.com/blog/2012/03/06/pest-control-2-electric-boogaloo/"/>
    <updated>2012-03-06T22:36:00-07:00</updated>
    <id>http://TagSoup.github.com/blog/2012/03/06/pest-control-2-electric-boogaloo</id>
    <content type="html"><![CDATA[<h3>Day 12 of the 30 Day Writing Challenge:</h3>

<p>Hello, I'm Truett Kueck and you're not.  Today I am going to expand on what I wrote about last week.  It is amazingly common to forget to add urls to links.  This is completely understandable.  You are developing the page in sprints, and sometimes the page you need to link to does not exist yet.  Multiple sprints later when that page exists it slips your mind and then BAM! a site is live with scores of non-functioning.  It is also possible, and very common, that the actual requirements for links are unclear or completely non-existent.</p>

<p>To solve this problem I have developed a simple Ruby application that parses a page for any links and then generates a Selenium script that clicks through the links on the page.  You will still need to make a few modifications, but you are 95% of the way there.  It uses the mechanize gem, another of many web automation gems, so we will need to install that first.</p>

<p><code>ruby
sudo gem install mechanize
</code></p>

<p>Mechanize is actually completely capable of performing the functionality of the Selenium script, but it has one major disadvantage.  The Selenium script can be run against Saucelab's <a href="http://www.saucelabs.com">OnDemandService</a> which gives you access to most every major OS/Browser combination.  That might not matter to you as a developer, but Compatibility Testing is the bread and butter of QA.  Now onto the code:</p>

<!--more-->


<p>```ruby
require 'rubygems'
require 'mechanize'</p>

<p>puts 'Please enter the url you\'d like to create a Selenium script for.'
url = gets.chomp
puts 'What would you like to name the script?'
filename = gets.chomp</p>

<p>agent = Mechanize.new
page = agent.get(url)
script = File.open(filename + '.rb', 'w')</p>

<p>pageLinks = []
page.links.each do |link|</p>

<pre><code>pageLinks.push(link.text)
</code></pre>

<p>end</p>

<p>script.puts 'require \'rubygems\''
script.puts 'require \'selenium-webdriver\''
script.puts
script.puts 'page = Selenium::WebDriver.for :firefox'
script.puts 'page.get(\'' + url + '\')'
script.puts</p>

<p>i = 0
pageLinks.each do |link|</p>

<pre><code>script.puts 'link' + i.to_s + ' = page.find_element(:link_text, \'' + link + '\')'
script.puts 'link' + i.to_s + '.click'
script.puts 'if page.title != PUT PAGE TITLE HERE'
script.puts '   puts \'Test failed\''
script.puts 'else'
script.puts '   puts \'Test Passed\''
script.puts 'end'
script.puts
script.puts 'page.quit'
script.puts 'page.get(\'' +url +'\')'
script.puts
i += 1
</code></pre>

<p>end
```</p>

<p>The user is initially prompted to enter the url they would like to run against.  This does require the url to be entered in http://www.url.com format, but you can add in error checking fairly easily.  They are then asked what they would like to name the script.  Then magic happens and we end up with a nearly ready-made Selenium script.  Now we need to update the script to actually check that the links are working.  The outputted code for a given link should look like:</p>

<p>```ruby
link0 = page.find_element(:link_text, 'Images')
link0.click
if page.title != PUT PAGE TITLE HERE</p>

<pre><code>puts 'Test failed'
</code></pre>

<p>else</p>

<pre><code>puts 'Test Passed'
</code></pre>

<p>end</p>

<p>page.quit
page.get('http://www.google.com')
```</p>

<p>The angry caps locked, "PUT PAGE TITLE HERE," is our target.  As I mentioned in the previous article: Selenium is capable of checking for things on the page other than the title.  If the link goes to content that is hidden, you can check for specific text.  Whichever you use replace that text with what you are looking for, and you are done.  Now go fourth and fix broken links.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QA - Pest control for development]]></title>
    <link href="http://TagSoup.github.com/blog/2012/02/29/qa-pest-control-for-development/"/>
    <updated>2012-02-29T21:26:00-07:00</updated>
    <id>http://TagSoup.github.com/blog/2012/02/29/qa-pest-control-for-development</id>
    <content type="html"><![CDATA[<h3>Day 6 of the 30 Day Writing Challenge</h3>

<p>I, unlike most of the Tag Soup group, am not a developer.  I’m currently a Web Tester at <a href="http://meltmedia.com/">melt media</a> and have held other QA titles at other organizations. QA is here to help you make better and higher quality products.  This is usually accomplished through two methods: manual testing and automated testing.  This post will concentrate on providing an introduction to automated testing using Selenium and Ruby.  Foreword before we get to any code: I’m still new to writing Ruby code.</p>

<p>First you’re going to need to have Ruby installed.  If you don’t already, follow <a href="http://www.ruby-lang.org/en/downloads/">this guide</a>.  Once that is accomplished you’ll need to install the Selenium webdriver gem.</p>

<p><code>ruby
Sudo gem install selenium-webdriver
</code></p>

<p>One more note before we get further into the code.  Automation is not a replacement for manual testing.  Anyone that tells you this is lying.  This post is going to cover using Selenium to automate link verification on marketing sites.  This seemingly innocuous test is very critical, and often overlooked in manual testing.
 <!--more--></p>

<p>```ruby
require ‘rubygems’
require ‘selenium-webdriver’</p>

<p>Driver = Selenium::WebDriver.for :firefox
```</p>

<p>This will create the object Page, which at this moment is a blank firefox window.  Loading any specific page is done by calling the Get method on that object.</p>

<p><code>ruby
url = ‘http://www.meltmedia.com’
Driver.get(url)
</code></p>

<p>Your browser should now be on the meltmedia homepage.  Now let’s make objects for each link.  I’m going to be finding the elements by the link text.  You should truthfully use :id, :class, or xpath where applicable as they’re less likely to change than the copy of a page.</p>

<p><code>ruby
workLink = Driver.find_element(:link_text, ‘Work’)
workLink.click
</code></p>

<p>You should now be on Melt’s portfolio page.  Now we have to check that the proper page loaded.  You can do this a number of ways.  You can search for specific elements, check the page title, or look for specific copy.   At the same time I’ll have the test output the results to the terminal.  You can output to a text file if you’d like as well.</p>

<p><code>ruby
if Driver.title != ‘Meltmedia – Our portfolio of client work’
  puts ‘Work  link failed to function properly’
else
  puts ‘Work link functioned properly’
end
</code></p>

<p>We now have a simple test that verifies a link.  We can use this test as a template for other link verification tests.  Either by making one long script that runs through ever links, or scripts for each individual links.  I prefer the later because it gives you granular results and lowers the chance of failure.  Since each test is independent of the previous, one test failing can’t cause another test to fail as well.</p>

<p>If you’d like to look up additonal information on Selenium please see <a href="http://seleniumhq.org/projects/webdriver/">selenium hq</a> and the <a href="http://code.google.com/p/selenium/">googs code</a></p>

<div class="clearfix">
<img class="left" src="http://s2.hubimg.com/u/4746909_f520.jpg" width="60">
<img class="left" src="http://s2.hubimg.com/u/4746909_f520.jpg" width="60">
<img class="left" src="http://s2.hubimg.com/u/4746909_f520.jpg" width="60">
<img class="left" src="http://s2.hubimg.com/u/4746909_f520.jpg" width="60">
<img class="left" src="http://s2.hubimg.com/u/4746909_f520.jpg" width="60">
</div>


<!-- / -->



]]></content>
  </entry>
  
</feed>
